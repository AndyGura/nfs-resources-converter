### TailLabs Roadmap and Milestones (AI‑generated)

Note: These milestones are AI‑generated by an assistant to help you plan the evolution of the project. Treat them as a proposal and adapt as needed. Rebranding to "TailLabs" is intentionally placed near the end, after quality and stability milestones.

#### Guiding principles
- Quality, stability, and contributor experience first; rebranding last
- Cross‑platform, zero‑setup downloads for Windows/macOS/Linux
- Two‑way workflows: open → edit → export to common formats → import back (when possible)
- Schema‑driven, plugin‑based format support to enable community contributions
- Keep documentation auto‑generated from source of truth
- Respect performance: batch/parallel, streaming, and memory safety

---

## Milestone 0 — Ground truth and stability foundation (current → next minor)
Focus: solidify what works today, fix rough edges, establish tests and reproducible builds.

Tasks
- Testing and verification
  - Establish golden sample corpus for NFS1–NFS2 resources (checked into `test/fixtures` or LFS). Add per‑format unit tests with round‑trip assertions where possible.  ✓/*
  - Create unit tests for utility functions and serializers.
  - Implement integration tests that exercise full conversion flows via CLI and GUI smoke paths.
  - Add property‑based tests (Hypothesis) for parsers that accept ranges/enums.
  - Hook fuzzing (Atheris) for binary parsers behind a CI flag.
  - Create reusable test fixtures for different resource types.
- Error handling and diagnostics
  - Implement consistent error handling across modules; standardize parser error classes and messages; include offset, field, and expected vs actual.
  - Add structured logs with file path, format, operation, and timing; surface in GUI status bar.
  - Implement secure error reporting (redact paths/user PII; provide copyable diagnostics in GUI).
- Performance and correctness
  - Audit parallel processing already implemented: ensure bounded concurrency, graceful shutdown, progress aggregation, and back‑pressure on I/O.
  - Add checksum or mtime‑based caching to skip re‑parsing unchanged inputs during batch conversion.
- Code quality and style
  - Add type hints throughout the codebase and run `mypy` (or pyright) in CI.
  - Implement linting and formatting (`flake8`/`ruff` + `black`); add pre‑commit hooks.
  - Add docstrings to all public functions, classes, and methods.
  - Reduce code duplication in parser implementations where quick wins exist.
- Configuration and safety
  - Create a configuration management system to replace hardcoded settings (paths to Blender/FFmpeg, defaults).
  - Implement a lightweight dependency injection pattern for better testability (e.g., pass services into API/CLI layers).
  - Implement baseline input validation for user‑supplied paths/arguments.
- Developer experience
  - Add `Makefile`/`invoke` tasks: `dev:setup`, `dev:test`, `dev:lint`, `dev:build:frontend`, `dev:package`.
  - Pin deterministic toolchain: Python version file, `requirements.txt` hashes, Node+Angular versions via `.nvmrc`/`package-lock.json`.
- CI
  - GitHub Actions: lint, type‑check, run tests (Linux/Windows/macOS), build Angular, run E2E smoke.
- Documentation
  - Keep `generate_resource_doc.py` as the source; ensure doc build target in CI to update `resources/README.md` on tags.
  - Enhance the README with more detailed setup instructions.
  - Document architecture and design decisions; add inline docs for complex algorithms.
  - Document the custom command system and provide examples.
  - Create a troubleshooting guide for common issues and environment setup.

Acceptance
- CI green across 3 OSes; golden tests passing; Angular build succeeds; converter smoke test on sample set passes.

---

## Milestone 1 — Cross‑platform packaging (no Python install required)
Focus: one‑click downloads with embedded runtime.

Tasks
- Desktop packaging
  - Bundle Python using PyInstaller or Briefcase; include Eel and Angular `dist` output.
  - Windows: produce signed `.exe` + optional `.msi`; set file associations for supported extensions.
  - macOS: notarized `.dmg`/`.pkg` app bundle; hardened runtime; Apple Silicon + Intel universal where feasible.
  - Linux: AppImage (.AppImage) and/or `.deb` via FPM; fallback portable tarball.
- First‑run experience
  - Out‑of‑the‑box defaults; auto‑detect Blender/FFmpeg, allow manual override in Settings.
  - Crash‑safe temp/output directories; error dialogs with copyable diagnostics.
- Release automation
  - GitHub Actions matrix build to produce and attach artifacts per‑tag.
  - Implement semantic versioning and tag‑driven releases.
  - Generate release notes automatically from conventional commits or PR labels.
  - Implement automatic update checks in the app with a safe download/apply flow.
- Frontend build assets
  - Set up proper asset management for the Angular frontend and ensure assets are bundled into desktop packages.
- Build performance
  - Optimize build process for faster development iteration (incremental Angular builds, caching in CI).

Acceptance
- Download → run on Windows/macOS/Linux without pre‑installed Python, venv, or Node.

---

## Milestone 2 — Two‑way conversion core (images, audio, simple models)
Focus: enable export to common formats and import back when feasible.

Tasks
- Images
  - PNG/JPEG export: preserve palettes, alpha; metadata JSON for non‑expressible fields.
  - Import from PNG back to original format if palette/bit‑depth constraints allow; surface limitations in UI.
- Audio
  - WAV export and re‑encode; import WAV back honoring sample rate/bit depth constraints.
- 3D models (phase 1)
  - Export: OBJ/GLB; include materials (MTL) and basic UVs; separate collision meshes if present.
  - Import back from OBJ/GLB for simple static meshes; record lossy steps in metadata.
- Editor safeguards and UX for conversions
  - Implement validation for edited resources prior to packing (ranges, enums, cross‑field constraints).
  - Implement a preview system for resource edits (images/audio immediate preview; 3D snapshot where feasible).
  - Implement export to additional common formats where practical (e.g., TIFF for images, FLAC/OGG for audio).
- Round‑trip testing
  - Add per‑format round‑trip tests with tolerances; mark unsupported paths explicitly.

Acceptance
- For selected NFS1/NFS2 formats: successful round‑trip with no structural corruption; UI exposes "Convert" and "Rebuild" clearly.

---

## Milestone 3 — GUI UX overhaul and Developer Tools
Focus: make editing easy for modders and empower contributors.

Tasks
- UX redesign (Angular + Eel)
  - New layout: left file tree, center viewer/editor, right properties/metadata, bottom logs.
  - Improve the resource navigation interface and add search for resources.
  - Persistent recent files, profiles, and batch queue; add support for batch processing in the GUI.
  - Add progress indicators and improved feedback for long‑running operations.
  - Implement keyboard shortcuts for common operations; add confirmation dialogs for destructive actions.
  - Improve error feedback and add more detailed error messages.
  - Implement responsive design and accessibility upgrades (ARIA, focus order, contrast).
  - Add theming support (light/dark mode).
  - Update Angular to the latest stable LTS and fix breaking changes.
  - In‑app updater/check for updates.
  - Create a more user‑friendly command‑line interface (rich help, progress bars, presets, examples).
- Dev Editor (power‑user mode)
  - Hex viewer with synchronized parsed structure overlay; jump‑to‑field and edit‑in‑place.
  - Structure constructor editor: live schema + data view; validate ranges/enums; preview pack result.
  - Save structure definitions to a portable schema file.
  - Add tutorials/tooltips and a user guide for the GUI editor.
- Feature tools
  - Create a resource comparison tool (diff between two resources in hex/structure view).
- Schema strategy
  - Prefer existing schema languages first: Kaitai Struct (`.ksy`) and 010 Editor Binary Templates.
  - Implement importers to translate external schemas to internal parsers; support metadata annotations for docs.
  - If needed, define a minimal internal schema DSL (YAML/JSON) for gaps not covered by Kaitai/010 BT.

Acceptance
- Hex+structure view operational; can edit fields and see live effect; schema files can be saved/loaded; contributors can add a new format using a schema import with minimal Python code.

---

## Milestone 4 — Plugin architecture and format registry
Focus: decouple core from formats to enable community growth.

Tasks
- Registry
  - Central `FormatRegistry` with discovery (entry points or module scanning) and versioned capabilities.
  - Each format declares: ids (magic/extension), parser, packer, converters (to/from), doc exporter, test vectors.
- Core refactors
  - Refactor the resource identification logic in `loader.py` to use the registry/factory pattern.
  - Refactor complex conditional logic in parser identification into table/strategy‑based dispatch.
  - Reduce duplication across parser implementations; extract common utilities.
- Plugin packaging
  - Support external `pip`-installable plugins and a `plugins/` folder for drop‑ins in bundled app.
  - Compatibility matrix and semantic‑versioned contracts.
- Developer documentation
  - Create developer docs for adding new resource parsers (schema‑first path, plugin structure, examples).
- CLI and GUI integration
  - List/enable/disable formats; show provenance and version.

Acceptance
- A sample external plugin (e.g., `tailabs-nfs-fsh`) can be installed and used without modifying core.

---

## Milestone 5 — 3D editing in GUI (phase 2)
Focus: interactive 3D edits for supported formats.

Tasks
- Integrate a lightweight WebGL viewer/editor in Angular for meshes (three.js)
  - Orbit controls, selection, transform gizmos, material/UV inspection.
- Edit pipeline
  - Edit in GUI → serialize to interchange (GLB) → convert to native via packer → preview in viewer.
  - Optional Blender round‑trip for advanced operations via background Blender Python if installed.
- Editor UX
  - Add undo/redo functionality for edits (structure and 3D ops), with history and safe rollback on pack errors.

Acceptance
- Users can perform basic mesh edits and save back to native for a subset of formats with clear limitations.

---

## Milestone 6 — Expanded game coverage (NFS 1→9 priority track)
Focus: broaden support across NFS 1–9 with documented formats.

Tasks
- Research and corpus building for each title; prioritize shared container/texture/mesh formats.
- Implement parsers via schema where possible; hand‑code only for tricky cases.
- Complete outstanding TODOs in `loader.py` for unimplemented resource formats.
- Continuous doc generation keeps `resources/README.md` authoritative.

Acceptance
- Public matrix lists read/write support per game and per asset type; docs auto‑generated.

---

## Milestone 7 — Performance, scalability, and robustness pass
Focus: handle large batches and stay responsive.

Tasks
- Profiling and benchmarks
  - Profile the application end‑to‑end to identify hotspots (CPU, I/O, memory) and add performance benchmarks for critical operations.
- Streaming and I/O
  - Streaming parsers/packers for large archives; chunked I/O.
- Concurrency governance
  - Worker pools sized by CPU/I/O; cancellation and retry policies.
- Memory and serialization
  - Memory audits, zero‑copy slices where safe; optimize serialization/deserialization of resources.
- Caching and lazy loading
  - Add caching for frequently accessed resources and lazy load heavy GUI components where possible.
- Integrity and security hardening
  - Add checksums for resource integrity verification and skip unchanged assets when safe.
  - Add safeguards against processing malicious files and enforce proper file permissions handling.
  - Implement secure error reporting across app and GUI.
- Telemetry and UX
  - Progress and telemetry exposed to GUI with ETA per batch.

Acceptance
- 10k‑file batch runs complete within expected time/memory budgets on CI perf job; UI stays responsive.

---

## Milestone 8 — Rebranding and polish
Focus: rename project to TailLabs (code and UI), website/docs polish.

Tasks
- Name/identifier updates: repo, app name, package namespaces; migration guide.
- Icons, splash, About page; signed releases; press‑ready README with screenshots and GIFs.
- Backward‑compat symlinks/redirects where applicable.

Acceptance
- TailLabs branding live; installers signed; README shows new identity; existing links redirect.

---

## Architecture review and targeted improvements

Observed today
- Angular frontend served via Eel; Python backend consolidates parsing/conversion; parallel processing present.
- `run.py` provides `gui`, `convert`, `custom_command`, and `show_settings` entry points.
- Auto‑generated documentation via `generate_resource_doc.py` writes to `resources/README.md`.

Recommendations
- Boundaries and layering
  - Define clear modules: `core` (I/O, errors), `formats` (plugins), `converters`, `ui_bridge` (Eel API), `cli`.
  - Introduce `FormatRegistry` and capability traits (parse/pack/convert/doc) with contracts and versioning.
- Schema‑first approach
  - Adopt Kaitai Struct where possible; build an importer and adapter so that a `.ksy` yields a Python parser and docs.
  - Keep `generate_resource_doc.py` consuming the same schema metadata to avoid divergence.
- API stability
  - Formalize a minimal stable interface for plugins and converters; document it; enforce via tests.
- Packaging
  - Move Angular build to `frontend/` with version pinning; Eel serves `dist/gui`; ensure PyInstaller spec includes static assets.
- Observability
  - Structured logs (JSON‑lines) with file+offset+operation; GUI log viewer with filtering.
- Testing
  - Golden corpus, round‑trip tests, property tests, fuzzing; wire into CI matrix and artifact retention.
- Performance
  - Review hot paths in `serializers/` and `library/read_blocks/`; avoid unnecessary copies; memory‑map large files where safe.

Directory structure (proposed, iterative)
- api/                 Python methods exposed to Eel (stable surface)
- core/                errors, utils, IO abstractions, concurrency helpers
- formats/             built‑in format packages (can be moved out later)
- plugins/             optional drop‑in directory for external plugins in bundled app
- converters/          common ↔ native conversions
- frontend/            Angular app (pinned toolchain)
- docs/                docs and generated assets
- scripts/             dev/ci scripts
- tests/               unit/property/fuzz tests and golden corpus

---

## Contribution and community
- CONTRIBUTING.md with PR checklist, code style, and how to add a new format (schema‑first path preferred).
- Template repository or `cookiecutter` for new format plugins.
- Good first issues and a public roadmap (this file) linked from README.

---

## Tracking and release cadence
- Use GitHub Projects/Issues linked to milestones above; keep a status badge in README.
- Aim for time‑boxed minor releases every 4–6 weeks; tag and auto‑publish installers via CI.
